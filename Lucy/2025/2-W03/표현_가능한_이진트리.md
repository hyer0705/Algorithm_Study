# 표현 가능한 이진트리

## 문제 정보

- URL: https://school.programmers.co.kr/learn/courses/30/lessons/150367
- LEVEL: Lv3
- Topics: 이진 트리, 재귀

## 문제 접근

문제를 풀기 위해 이진 트리와 포화 이진 트리에 대해 이해할 필요가 있어 해당 개념들을 먼저 공부한 내용들을 정리해봤습니다.

### 이진 트리?

이진 트리는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 구조입니다. 트리의 각 노드는 두 가지 자식 노드를 가질 수 있는데, 각각 왼쪽 자식과 오른쪽 자식입니다. 이진 트리는 다음과 같은 특성을 가집니다:

- 루트 노드: 트리의 시작 노드.
- 리프 노드 (Leaf Node): 자식 노드가 없는 노드.
- 내부 노드 (Internal Node): 자식 노드를 가진 노드.
- 깊이 (Depth): 루트 노드에서 해당 노드까지의 경로 길이.
- 높이 (Height): 트리에서 가장 깊은 리프 노드까지의 경로 길이.

이진 트리는 다양한 형태로 사용되며, 예를 들어 **이진 탐색 트리 (Binary Search Tree)**에서는 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큰 값을 갖는 규칙을 따릅니다.

### 포화 이진 트리?

포화 이진 트리는 모든 레벨이 완전히 채워진 이진 트리입니다. 즉, 각 레벨에서 가능한 모든 노드가 존재하는 트리를 의미합니다. 포화 이진 트리의 특성은 다음과 같습니다:

- 모든 레벨이 가득 차 있다: 마지막 레벨을 제외한 모든 레벨에서, 노드들이 최대 개수만큼 존재합니다.
- 각 내부 노드가 두 자식 노드를 가진다: 포화 이진 트리에서 모든 내부 노드는 정확히 두 개의 자식 노드를 가집니다.
- 노드의 수: 포화 이진 트리에서 노드의 수는 (2^(h+1) - 1)과 같은 수식으로 표현됩니다. 여기서 h는 트리의 높이입니다. 예를 들어, 높이가 2인 포화 이진 트리는 7개의 노드를 가집니다 (1 + 2 + 4 = 7).

### 코드 해설

이 문제는 주어진 숫자를 이진트리 형태로 표현하고, 그 이진트리가 포화 이진트리인지 확인하는 문제입니다. 포화 이진트리에서 각 노드는 특정 규칙을 따르며, 이를 만족하는지 확인하는 방식으로 풀이를 진행했습니다.

1. 이진수 변환 및 포화 이진트리 형태 만들기

- 주어진 숫자를 이진수로 변환한 뒤, 그 길이가 포화 이진트리 형태로 맞춰지도록 padStart를 사용하여 앞에 0을 채워줍니다.
- 포화 이진트리의 노드는 (2^(h+1) - 1)개의 노드를 가지며, 이진수의 길이가 포화 이진트리의 노드 수로 맞춰지도록 조정합니다.

```typescript
let binary = number.toString(2);

let h = 0;
let totalNode = 1;
while (totalNode < binary.length) {
  h++;
  totalNode = 2 ** (h + 1) - 1;
}

binary = binary.padStart(totalNode, "0");
```

2. 이진트리의 유효성 검사

- isValidSubtree 함수는 재귀적으로 서브트리의 유효성을 검사합니다.
- 포화 이진트리의 특징을 고려하여, 루트 노드를 중심으로 왼쪽과 오른쪽 서브트리의 유효성을 검사합니다.
- 이 함수는 트리의 부모 노드를 기준으로 그 서브트리가 "1"을 포함하지 않도록 하며, 부모가 "0"일 경우 자식 노드들이 "1"이 되지 않도록 조건을 설정합니다.

```typescript
const isValidSubtree = (binary, startIndex, endIndex) => {
  if (startIndex >= endIndex) return true;

  const parentIndex = Math.floor((startIndex + endIndex) / 2);
  if (binary[parentIndex] === "0") {
    for (let i = startIndex; i <= endIndex; i++) {
      if (binary[i] === "1") return false;
    }
  }

  return isValidSubtree(binary, startIndex, parentIndex - 1) && isValidSubtree(binary, parentIndex + 1, endIndex);
};
```

3. 트리의 유효성 검증

- 만약 이진수에서 루트 노드가 "1"이고, 서브트리도 유효하다면 그 숫자는 유효한 이진트리로 표현될 수 있는 수임을 확인합니다.
- 각 숫자에 대해 위의 조건을 만족하는지 체크하고, 만족하면 1을, 아니면 0을 배열에 추가하여 반환합니다.

```typescript
for (const number of numbers) {
  // ...
  let rootNodeIndex = Math.floor(totalNode / 2);
  if (binary[rootNodeIndex] === "1" && isValidSubtree(binary, 0, totalNode - 1)) {
    answer.push(1);
  } else {
    answer.push(0);
  }
}
```

4. 결과 반환

- 모든 숫자에 대한 검사 후, 유효한 이진트리 표현 여부를 담은 배열을 반환합니다.

```typescript
return answer;
```

## 문제 회고

문제의 요구사항을 분석하면서, 포화 이진트리와 이진수 변환 과정의 규칙을 파악하는 것이 핵심이라고 생각했다.

나름대로 문제를 이해하고 규칙을 찾아내어 다음과 같은 흐름으로 문제를 풀이했다.

- 주어진 숫자를 이진수로 변환한다.
- 포화 이진트리 형태를 유지하기 위해 노드 개수를 조정한다.
- 트리의 루트가 적절한지 확인한다.
- 유효한 트리 구조인지 검사하여 결과를 반환한다.

이러한 흐름으로 구현을 시도했지만, 포화 이진트리의 개념을 완전히 이해하지 못해 한 개의 테스트 케이스만 통과하는 코드가 나왔다. 결국 카카오 테크 블로그의 해설을 참고하며 부족했던 부분을 보완했다. 특히, 포화 이진트리로 변환하는 과정, 루트 노드의 유효성 검사 방법, 트리 구조의 유효성 판단 방식 이 세 가지 핵심 개념을 제대로 이해하지 못했다는 점을 깨달았다. 이를 수정하면서 이진트리의 개념과 재귀적인 탐색 방법을 깊이 있게 학습할 수 있었다.

## 참고 자료
