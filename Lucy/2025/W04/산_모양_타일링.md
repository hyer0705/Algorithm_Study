# 산 모양 타일링

## 문제 정보

- URL: https://school.programmers.co.kr/learn/courses/30/lessons/258705
- Level: Lv3
- Topics: Dynamic Programming

## 문제 접근

- 목표: 정삼각형 타일과 마름모 타일로 빈 곳 없이 사다리꼴을 채우는 경우의 수를 구합니다.
- 제약 조건: 타일 배치가 겹치지 않고 사다리꼴 경계를 벗어나질 않아야 하며, 경우의 수를 10007로 나눈 나머지를 반환해야 합니다.
- 핵심 개념
  - 아래 방향 정삼각형을 덮는 방법 네가지:
    1. 위쪽 정삼각형과 함께 마름모 타일로 덮기
    2. 왼쪽 정삼각형과 함께 마름모 타일로 덮기
    3. 오른쪽 정삼각형과 함께 마름모 타일로 덮기
    4. 정삼각형 타일로 덮기
  - 1번은 위쪽 정삼각형이 존재해야만 가능
  - 직전 정삼각형의 덮는 방식이 현재 정삼각형에 영향을 미침

### 점화식 설계

아래 방향 정삼각형을 덮는 방법을 두 배열로 나누어 정의

- arrA[k]: k번째 정삼각형을 3번 방식으로 덮는 경우의 수 (아래 방향 정삼각형 + 오른쪽 정삼각형)
- arrB[k]: k번째 정삼각형을 3번 방식이 아닌 방법으로 덮는 경우의 수 (withour 아래 방향 정삼각형 + 오른쪽 정삼각형)

#### 초기값

점화식의 초기 조건으로, 이후 타일링의 경우의 수를 계산하는 출발점

- arrA[0] = 0?

  - arrA[k]는 k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법인 경우의 수를 나타냅니다.
  - arrA[0]은 "0번째 정삼각형을 덮는 경우"이므로, 사실 덮을 정삼각형이 없을 때의 경우를 나타냅니다. 이 경우에는 arrA[0]을 0으로 초기화합니다.

- arrB[0] = 1?
  - arrB[k]는 k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법이 아닌 경우의 수를 나타냅니다.
  - arrB[0]은 "0번째 정삼각형을 덮는 경우"이므로, 초기 상태에서 arrB[0]은 "아무 것도 덮지 않은 상태에서 시작하는 경우"로 간주됩니다.
  - 알고리즘의 시작점으로서 의미를 가져 1로 초기화합니다. arrB의 경우 곱하기 연산이 진행되기 때문에 0으로 초기화를 하면 모든 값이 0이 되어버리기 때문에 1로 초기화합니다.

```javascript
const arrA = new Array(n + 1).fill(0);
const arrB = new Array(n + 1).fill(0);

arrA[0] = 0;
arrB[0] = 1;
```

#### 위쪽 정삼각형이 있는 경우(tops[i - 1] = 1)

```javascript
arrA[i] = arrA[i - 1] + arrB[i - 1];
if (tops[i - 1] === 1) {
  arrB[i] = 2 * arrA[i - 1] + 3 * arrB[i - 1];
}
```

#### 위쪽 정삼각형이 없는 경우(tops[i - 1] = 0)

```javascript
arrA[i] = arrA[i - 1] + arrB[i - 1];
if (tops[i - 1] === 0) {
  arrB[i] = arrA[i - 1] + 2 * arrB[i - 1];
}
```

#### 최종 결과

arrA[n] + arrB[n]: n번째까지 타일링한 경우의 수

```javascript
return (arrA[n] + arrB[n]) % 10007;
```

## 문제 회고

문제의 설명은 이해했지만, 처음에는 어떻게 접근해야 할지 전혀 감이 잡히지 않았습니다. 문제를 풀기 위한 규칙이 있을 것 같아 n이 작은 경우부터 직접 그림을 그려가며 시도해 보았습니다. 예를 들어, n = 1, n = 2인 경우를 그려봤지만, 명확한 규칙을 발견하지 못했습니다.

1시간 정도 고민한 끝에 스스로 해결할 수 없다는 것을 인정하고, 카카오 테크 블로그에서 문제 해설을 찾아보았습니다. 이 문제는 Dynamic Programming(DP) 유형으로, 문제를 해결하기 위해 점화식을 세워야 한다는 것을 알게 되었습니다. 해설에 나와 있는 점화식을 참고해 코드를 작성한 뒤 제출했지만, 처음에는 29.2점이라는 낮은 점수를 받았습니다.

문제를 다시 검토해보니, 10007로 나눈 나머지를 반환해야 한다는 조건을 처리하는 부분에서 실수가 있었음을 발견했습니다. n = 1일 때의 결과값을 포함해 DP 배열의 모든 계산 과정에서 10007로 나머지 연산을 적용하도록 수정했습니다. 이 과정을 거친 후, 문제를 통과할 수 있었습니다.

이번 경험을 통해 DP 문제는 규칙을 찾고 점화식을 세우는 것이 핵심임을 다시 깨달았습니다. 하지만 여전히 점화식을 세우는 과정이 익숙하지 않아 어렵습니다. 이를 극복하기 위해 프로그래머스나 백준에서 더 쉬운 DP 문제부터 연습하며 규칙을 발견하는 연습을 꾸준히 해나가야겠다고 생각했습니다.

## 참고 자료

- [카카오 테크 블로그](https://tech.kakao.com/posts/610)
