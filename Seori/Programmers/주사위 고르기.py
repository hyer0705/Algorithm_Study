from itertools import combinations, product
def solution(dice):
    # 변수 선언
    n = len(dice)
    숫자조합 = list(combinations(list(i+1 for i in range(n)), n//2))
    주사위조합 = list(combinations(dice, n//2))
    조합길이 = len(주사위조합)
    최다승리 = 0
    answer = []

    # [1] 각 주사위를 고르는 경우의 수를 combinations 조합을 활용해서 뽑아낸다.
    #     이 때 조합은 좌우대칭 쌍으로 이뤄지기 때문에 인덱스의 절반까지만 탐색했다.
    for i in range(조합길이//2):
        선택주사위, 상대주사위 = 주사위조합[i], 주사위조합[조합길이-1-i]

        # [2] product를 사용해서 각 주사위를 굴려 나오는 모든 곱셈의 경우의 수를 저장한다.
        선택주사위_곱셈경우의수 = []
        for 선택주사위_숫자조합 in list(product(*선택주사위)):
            곱 = 1
            for 숫자 in 선택주사위_숫자조합:
                곱 *= 숫자
            선택주사위_곱셈경우의수.append(곱)
            
        상대주사위_곱셈경우의수 = []
        for 상대주사위_숫자조합 in list(product(*상대주사위)):
            곱 = 1
            for 숫자 in 상대주사위_숫자조합:
                곱 *= 숫자
            상대주사위_곱셈경우의수.append(곱)
            
        # [3] 저장한 모든 경우의 수를 비교하여 각 주사위조합의 승률을 계산한다.
        #     조합 특성상 상대방이 승리한 경우를 같은 반복문에서 계산해도 상관없기에 승/패로 나누어 같이 비교했다.
        #     모든 곱셈의 경우의 수를 정렬한 뒤, 탐색 시간을 줄이기 위해 while문으로 탐색을 단순화해보았다.
        선택주사위_곱셈경우의수.sort()
        상대주사위_곱셈경우의수.sort()

        경우의수 = len(상대주사위_곱셈경우의수)
        승, 패 = 0, 0
        인덱스 = 0
        for 숫자 in 선택주사위_곱셈경우의수:
            while 인덱스 < 경우의수 and 숫자 > 상대주사위_곱셈경우의수[인덱스]:
                인덱스 += 1
            승 += 인덱스
        
        # [4] 반복문에서 기록한 승/패가 역대 최다라면 그 때의 주사위 조합을 answer에 저장하고 마지막에 반환한다.
        if 승 > 최다승리:
            최다승리 = 승
            answer = 숫자조합[i]
            
        인덱스 = 0
        for 숫자 in 상대주사위_곱셈경우의수:
            while 인덱스 < 경우의수 and 숫자 > 선택주사위_곱셈경우의수[인덱스]:
                인덱스 += 1
            패 += 인덱스
        
        if 패 > 최다승리:
            최다승리 = 패
            answer = 숫자조합[조합길이-1-i]

    return answer